<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.1" />
<title>fault.verilator_target API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id=^header-]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:1px solid #ddd;margin:1em 0 1em 4ch}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}#index .two-column{column-count:2}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{background:#ffc;font-weight:400;font-size:.8em;width:11em;text-transform:uppercase;padding:0px 8px;border:1px solid #fd6;border-radius:5px;cursor:pointer}.source summary:hover{background:#fe9 !important}.source[open] summary{background:#fda}.source pre{max-height:500px;overflow-y:scroll;margin-bottom:15px}.hlist{list-syle:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink;]</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>fault.verilator_target</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import fault
from .array import Array
from pathlib import Path
import subprocess
import magma as m
import fault.actions as actions
from fault.actions import Poke, Eval
from fault.verilog_target import VerilogTarget, verilog_name
import fault.value_utils as value_utils
import fault.verilator_utils as verilator_utils
from fault.select_path import SelectPath
from fault.wrapper import PortWrapper, InstanceWrapper
import math
from hwtypes import BitVector, SIntVector
import subprocess
from fault.random import random_bv
import fault.utils as utils
import platform
import os


src_tpl = &#34;&#34;&#34;\
{includes}

// Based on https://www.veripool.org/projects/verilator/wiki/Manual-verilator#CONNECTING-TO-C
vluint64_t main_time = 0;       // Current simulation time
// This is a 64-bit integer to reduce wrap over issues and
// allow modulus.  You can also use a double, if you wish.

double sc_time_stamp () {{       // Called by $time in Verilog
    return main_time;           // converts to double, to match
                                // what SystemC does
}}

#if VM_TRACE
VerilatedVcdC* tracer;
#endif

void my_assert(
    unsigned int got,
    unsigned int expected,
    int i,
    const char* port) {{
  if (got != expected) {{
    std::cerr &lt;&lt; std::endl;  // end the current line
    std::cerr &lt;&lt; \&#34;Got      : 0x\&#34; &lt;&lt; std::hex &lt;&lt; got &lt;&lt; std::endl;
    std::cerr &lt;&lt; \&#34;Expected : 0x\&#34; &lt;&lt; std::hex &lt;&lt; expected &lt;&lt; std::endl;
    std::cerr &lt;&lt; \&#34;i        : \&#34; &lt;&lt; std::dec &lt;&lt; i &lt;&lt; std::endl;
    std::cerr &lt;&lt; \&#34;Port     : \&#34; &lt;&lt; port &lt;&lt; std::endl;
#if VM_TRACE
    tracer-&gt;close();
#endif
    exit(1);
  }}
}}

int main(int argc, char **argv) {{
  Verilated::commandArgs(argc, argv);
  V{circuit_name}* top = new V{circuit_name};

#if VM_TRACE
  Verilated::traceEverOn(true);
  tracer = new VerilatedVcdC;
  top-&gt;trace(tracer, 99);
  mkdir(&#34;logs&#34;, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
  tracer-&gt;open(&#34;logs/{circuit_name}.vcd&#34;);
#endif

{main_body}

#if VM_TRACE
  tracer-&gt;close();
#endif
}}
&#34;&#34;&#34;  # nopep8


class VerilatorTarget(VerilogTarget):
    def __init__(self, circuit, directory=&#34;build/&#34;,
                 flags=[], skip_compile=False, include_verilog_libraries=[],
                 include_directories=[], magma_output=&#34;coreir-verilog&#34;,
                 circuit_name=None, magma_opts={}):
        &#34;&#34;&#34;
        Params:
            `include_verilog_libraries`: a list of verilog libraries to include
            with the -v flag.  From the verilator docs:
                -v &lt;filename&gt;              Verilog library

            `include_directories`: a list of directories to include using the
            -I flag. From the the verilator docs:
                -I&lt;dir&gt;                    Directory to search for includes
        &#34;&#34;&#34;
        super().__init__(circuit, circuit_name, directory, skip_compile,
                         include_verilog_libraries, magma_output, magma_opts)
        self.flags = flags
        self.include_directories = include_directories

        # Compile the design using `verilator`
        driver_file = self.directory / Path(f&#34;{self.circuit_name}_driver.cpp&#34;)
        verilator_cmd = verilator_utils.verilator_cmd(
            self.circuit_name, self.verilog_file.name,
            self.include_verilog_libraries, self.include_directories,
            driver_file.name, self.flags)
        if self.run_from_directory(verilator_cmd):
            raise Exception(f&#34;Running verilator cmd {verilator_cmd} failed&#34;)
        self.debug_includes = set()
        verilator_version = subprocess.check_output(&#34;verilator --version&#34;,
                                                    shell=True)
        # Need to check version since they changed how internal signal access
        # works
        self.verilator_version = float(verilator_version.split()[1])

    def make_poke(self, i, action):
        if self.verilator_version &gt; 3.874:
            prefix = f&#34;{self.circuit_name}&#34;
        else:
            prefix = f&#34;v&#34;
        if isinstance(action.port, fault.WrappedVerilogInternalPort):
            path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
            name = f&#34;{prefix}-&gt;{path}&#34;
        elif isinstance(action.port, SelectPath):
            name = &#34;&#34;
            if len(action.port) &gt; 2:
                # TODO: Find the version that they changed this, 3.874 is known
                # to use top-&gt;v instead of top-&gt;{circuit_name}
                name += f&#34;{prefix}-&gt;&#34;
            name += action.port.verilator_path
            if len(action.port) &gt; 2:
                self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
            for item in action.port[1:-1]:
                circuit = type(item.instance)
                circuit_name = circuit.verilog_name
                # Verilator specializes each parametrization into a separate
                # mdoule, this is an attempt to reverse engineer the naming
                # scheme
                if circuit_name == &#34;coreir_reg&#34;:
                    circuit_name += &#34;_&#34;
                    circuit_name += f&#34;_I{circuit.coreir_configargs[&#39;init&#39;]}&#34;
                    circuit_name += f&#34;_W{circuit.coreir_genargs[&#39;width&#39;]}&#34;
                elif circuit_name == &#34;coreir_reg_arst&#34;:
                    circuit_name += &#34;_&#34;
                    circuit_name += f&#34;_I{circuit.coreir_configargs[&#39;init&#39;]}&#34;
                    if circuit.coreir_genargs[&#39;width&#39;] != 1:
                        circuit_name += f&#34;_W{circuit.coreir_genargs[&#39;width&#39;]}&#34;
                self.debug_includes.add(f&#34;{circuit_name}&#34;)
        else:
            name = verilog_name(action.port.name)

        # Special case poking internal registers
        is_reg_poke = isinstance(action.port, SelectPath) and \
            isinstance(action.port[-1], fault.WrappedVerilogInternalPort) \
            and action.port[-1].path == &#34;outReg&#34;

        max_bits = 64 if platform.architecture()[0] == &#34;64bit&#34; else 32
        if isinstance(action.value, BitVector) and \
                action.value.num_bits &gt; max_bits:
            asserts = []
            for i in range(math.ceil(action.value.num_bits / max_bits)):
                value = action.value[i * max_bits:min(
                    (i + 1) * max_bits, action.value.num_bits)]
                asserts += [f&#34;top-&gt;{name}[{i}] = {value};&#34;]
            if is_reg_poke:
                raise NotImplementedError()
            return asserts
        else:
            value = action.value
            if isinstance(action.port, m.SIntType) and value &lt; 0:
                # Handle sign extension for verilator since it expects and
                # unsigned c type
                port_len = len(action.port)
                value = BitVector(value, port_len).as_uint()
            result = [f&#34;top-&gt;{name} = {value};&#34;]
            # Hack to support verilator&#39;s semantics, need to set the register
            # mux values for expected behavior
            if is_reg_poke:
                action.port[-1].path = &#34;out&#34;
                result += self.make_poke(i, action)
                action.port[-1].path = &#34;in&#34;
                result += self.make_poke(i, action)
                if &#34;enable_mux&#34; in action.port[-3].instance_map:
                    mux_inst = action.port[-3].instance_map[&#34;enable_mux&#34;]
                    action.port[-2] = InstanceWrapper(mux_inst, action.port[-3])
                    action.port[-1] = type(mux_inst).I0
                    result += self.make_poke(i, action)
            return result

    def make_print(self, i, action):
        name = verilog_name(action.port.name)
        return [f&#39;printf(&#34;{action.port.debug_name} = &#39;
                f&#39;{action.format_str}\\n&#34;, top-&gt;{name});&#39;]

    def make_expect(self, i, action):
        # For verilator, if an expect is &#34;AnyValue&#34; we don&#39;t need to
        # perform the expect.
        if value_utils.is_any(action.value):
            return []
        if self.verilator_version &gt; 3.874:
            prefix = f&#34;{self.circuit_name}&#34;
        else:
            prefix = f&#34;v&#34;
        if isinstance(action.port, fault.WrappedVerilogInternalPort):
            path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
            name = f&#34;{prefix}-&gt;{path}&#34;
            debug_name = name
        elif isinstance(action.port, SelectPath):
            name = action.port.verilator_path
            if len(action.port) &gt; 2:
                name = f&#34;{prefix}-&gt;&#34; + name
            if self.verilator_version &gt;= 3.856:
                if len(action.port) &gt; 2:
                    self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
            for item in action.port[1:-1]:
                circuit_name = type(item.instance).name
                self.debug_includes.add(f&#34;{circuit_name}&#34;)
            debug_name = action.port[-1].debug_name
        else:
            name = verilog_name(action.port.name)
            debug_name = action.port.debug_name
        value = action.value
        if isinstance(value, actions.Peek):
            if isinstance(value.port, fault.WrappedVerilogInternalPort):
                path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
                value = f&#34;top-&gt;{prefix}-&gt;{path}&#34;
            else:
                value = f&#34;top-&gt;{verilog_name(value.port.name)}&#34;
        elif isinstance(value, PortWrapper):
            if self.verilator_version &gt;= 3.856:
                if len(action.port) &gt; 2:
                    self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
            for item in value.select_path[1:-1]:
                circuit_name = type(item.instance).name
                self.debug_includes.add(f&#34;{circuit_name}&#34;)
            value = f&#34;top-&gt;{prefix}-&gt;&#34; + value.select_path.verilator_path
        elif isinstance(action.port, m.SIntType) and value &lt; 0:
            # Handle sign extension for verilator since it expects and
            # unsigned c type
            port_len = len(action.port)
            value = BitVector(value, port_len).as_uint()

        return [f&#34;my_assert(top-&gt;{name}, {value}, &#34;
                f&#34;{i}, \&#34;{debug_name}\&#34;);&#34;]

    def make_eval(self, i, action):
        return [&#34;top-&gt;eval();&#34;, &#34;main_time++;&#34;, &#34;#if VM_TRACE&#34;,
                &#34;tracer-&gt;dump(main_time);&#34;, &#34;#endif&#34;]

    def make_step(self, i, action):
        name = verilog_name(action.clock.name)
        code = []
        for step in range(action.steps):
            code.append(&#34;top-&gt;eval();&#34;)
            code.append(&#34;main_time++;&#34;)
            code.append(&#34;#if VM_TRACE&#34;)
            code.append(&#34;tracer-&gt;dump(main_time);&#34;)
            code.append(&#34;#endif&#34;)
            code.append(f&#34;top-&gt;{name} ^= 1;&#34;)
        return code

    def generate_code(self, actions, verilator_includes, num_tests, circuit):
        if verilator_includes:
            # Include the top circuit by default
            verilator_includes.insert(
                0, f&#39;{self.circuit_name}&#39;)
        includes = [
            f&#39;&#34;V{self.circuit_name}.h&#34;&#39;,
        ] + [f&#39;&#34;V{self.circuit_name}_{include}.h&#34;&#39; for include in
             verilator_includes] + [
            &#39;&#34;verilated.h&#34;&#39;,
            &#39;&lt;iostream&gt;&#39;,
            &#39;&lt;verilated_vcd_c.h&gt;&#39;,
            &#39;&lt;sys/types.h&gt;&#39;,
            &#39;&lt;sys/stat.h&gt;&#39;,
        ]

        main_body = &#34;&#34;
        for i, action in enumerate(actions):
            code = self.generate_action_code(i, action)
            for line in code:
                main_body += f&#34;  {line}\n&#34;

        for i in range(num_tests):
            main_body += self.add_assumptions(circuit, actions, i)
            code = self.make_eval(i, Eval())
            for line in code:
                main_body += f&#34;  {line}\n&#34;
            main_body += self.add_guarantees(circuit, actions, i)

        includes += [f&#39;&#34;V{self.circuit_name}_{include}.h&#34;&#39; for include in
                     self.debug_includes]

        includes_src = &#34;\n&#34;.join([&#34;#include &#34; + i for i in includes])
        src = src_tpl.format(
            includes=includes_src,
            main_body=main_body,
            circuit_name=self.circuit_name,
        )

        return src

    def run_from_directory(self, cmd):
        return subprocess.call(cmd, cwd=self.directory, shell=True)

    def run(self, actions, verilator_includes=[], num_tests=0,
            _circuit=None):
        driver_file = self.directory / Path(f&#34;{self.circuit_name}_driver.cpp&#34;)
        # Write the verilator driver to file.
        src = self.generate_code(actions, verilator_includes, num_tests,
                                 _circuit)
        with open(driver_file, &#34;w&#34;) as f:
            f.write(src)
        # Run a series of commands: run the Makefile output by verilator, and
        # finally run the executable created by verilator.
        verilator_make_cmd = verilator_utils.verilator_make_cmd(
            self.circuit_name)
        assert not self.run_from_directory(verilator_make_cmd)
        assert not self.run_from_directory(f&#34;./obj_dir/V{self.circuit_name}&#34;)

    def add_assumptions(self, circuit, actions, i):
        main_body = &#34;&#34;
        for port in circuit.interface.ports.values():
            if port.isoutput():
                for assumption in self.assumptions:
                    # TODO: Chained assumptions?
                    assume_port = assumption.port
                    if isinstance(assume_port, SelectPath):
                        assume_port = assume_port[-1]
                    if assume_port is port:
                        pred = assumption.value
                        while True:
                            randval = random_bv(len(assume_port))
                            if pred(randval):
                                break
                        code = self.make_poke(
                            len(actions) + i, Poke(port, randval))
                        for line in code:
                            main_body += f&#34;  {line}\n&#34;
                        break
        return main_body

    def add_guarantees(self, circuit, actions, i):
        main_body = &#34;&#34;
        for name, port in circuit.interface.ports.items():
            if port.isinput():
                for guarantee in self.guarantees:
                    guarantee_port = guarantee.port
                    if isinstance(guarantee_port, SelectPath):
                        guarantee_port = guarantee_port[-1]
                    if guarantee_port is port:
                        # TODO: Support functions too
                        code = utils.get_short_lambda_body_text(guarantee.value)
                        # TODO: More robust symbol replacer on AST
                        for port in circuit.interface.ports:
                            code = code.replace(&#34;and&#34;, &#34;&amp;&amp;&#34;)
                            code = code.replace(port, f&#34;top-&gt;{port}&#34;)
                        main_body += f&#34;&#34;&#34;\
    if (!({code})) {{
      std::cerr &lt;&lt; std::endl;  // end the current line
      std::cerr &lt;&lt; \&#34;Got      : 0x\&#34; &lt;&lt; std::hex &lt;&lt; top-&gt;{name} &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;Expected : {code}&#34; &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;i        : {i}\&#34; &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;Port     : {name}\&#34; &lt;&lt; std::endl;
      #if VM_TRACE
        tracer-&gt;close();
      #endif
      exit(1);
    }}
&#34;&#34;&#34;
        return main_body}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fault.verilator_target.VerilatorTarget"><code class="flex name class">
<span>class <span class="ident">VerilatorTarget</span></span>
<span>(</span><span><small>ancestors:</small> <a title="fault.verilog_target.VerilogTarget" href="verilog_target.html#fault.verilog_target.VerilogTarget">VerilogTarget</a>, <a title="fault.target.Target" href="target.html#fault.target.Target">Target</a>, abc.ABC)</span>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="fault.verilog_target.VerilogTarget" href="verilog_target.html#fault.verilog_target.VerilogTarget">VerilogTarget</a></code>
</p>
<section class="desc inherited"><p>Provides reuseable target logic for compiling circuits into verilog files.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class VerilatorTarget(VerilogTarget):
    def __init__(self, circuit, directory=&#34;build/&#34;,
                 flags=[], skip_compile=False, include_verilog_libraries=[],
                 include_directories=[], magma_output=&#34;coreir-verilog&#34;,
                 circuit_name=None, magma_opts={}):
        &#34;&#34;&#34;
        Params:
            `include_verilog_libraries`: a list of verilog libraries to include
            with the -v flag.  From the verilator docs:
                -v &lt;filename&gt;              Verilog library

            `include_directories`: a list of directories to include using the
            -I flag. From the the verilator docs:
                -I&lt;dir&gt;                    Directory to search for includes
        &#34;&#34;&#34;
        super().__init__(circuit, circuit_name, directory, skip_compile,
                         include_verilog_libraries, magma_output, magma_opts)
        self.flags = flags
        self.include_directories = include_directories

        # Compile the design using `verilator`
        driver_file = self.directory / Path(f&#34;{self.circuit_name}_driver.cpp&#34;)
        verilator_cmd = verilator_utils.verilator_cmd(
            self.circuit_name, self.verilog_file.name,
            self.include_verilog_libraries, self.include_directories,
            driver_file.name, self.flags)
        if self.run_from_directory(verilator_cmd):
            raise Exception(f&#34;Running verilator cmd {verilator_cmd} failed&#34;)
        self.debug_includes = set()
        verilator_version = subprocess.check_output(&#34;verilator --version&#34;,
                                                    shell=True)
        # Need to check version since they changed how internal signal access
        # works
        self.verilator_version = float(verilator_version.split()[1])

    def make_poke(self, i, action):
        if self.verilator_version &gt; 3.874:
            prefix = f&#34;{self.circuit_name}&#34;
        else:
            prefix = f&#34;v&#34;
        if isinstance(action.port, fault.WrappedVerilogInternalPort):
            path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
            name = f&#34;{prefix}-&gt;{path}&#34;
        elif isinstance(action.port, SelectPath):
            name = &#34;&#34;
            if len(action.port) &gt; 2:
                # TODO: Find the version that they changed this, 3.874 is known
                # to use top-&gt;v instead of top-&gt;{circuit_name}
                name += f&#34;{prefix}-&gt;&#34;
            name += action.port.verilator_path
            if len(action.port) &gt; 2:
                self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
            for item in action.port[1:-1]:
                circuit = type(item.instance)
                circuit_name = circuit.verilog_name
                # Verilator specializes each parametrization into a separate
                # mdoule, this is an attempt to reverse engineer the naming
                # scheme
                if circuit_name == &#34;coreir_reg&#34;:
                    circuit_name += &#34;_&#34;
                    circuit_name += f&#34;_I{circuit.coreir_configargs[&#39;init&#39;]}&#34;
                    circuit_name += f&#34;_W{circuit.coreir_genargs[&#39;width&#39;]}&#34;
                elif circuit_name == &#34;coreir_reg_arst&#34;:
                    circuit_name += &#34;_&#34;
                    circuit_name += f&#34;_I{circuit.coreir_configargs[&#39;init&#39;]}&#34;
                    if circuit.coreir_genargs[&#39;width&#39;] != 1:
                        circuit_name += f&#34;_W{circuit.coreir_genargs[&#39;width&#39;]}&#34;
                self.debug_includes.add(f&#34;{circuit_name}&#34;)
        else:
            name = verilog_name(action.port.name)

        # Special case poking internal registers
        is_reg_poke = isinstance(action.port, SelectPath) and \
            isinstance(action.port[-1], fault.WrappedVerilogInternalPort) \
            and action.port[-1].path == &#34;outReg&#34;

        max_bits = 64 if platform.architecture()[0] == &#34;64bit&#34; else 32
        if isinstance(action.value, BitVector) and \
                action.value.num_bits &gt; max_bits:
            asserts = []
            for i in range(math.ceil(action.value.num_bits / max_bits)):
                value = action.value[i * max_bits:min(
                    (i + 1) * max_bits, action.value.num_bits)]
                asserts += [f&#34;top-&gt;{name}[{i}] = {value};&#34;]
            if is_reg_poke:
                raise NotImplementedError()
            return asserts
        else:
            value = action.value
            if isinstance(action.port, m.SIntType) and value &lt; 0:
                # Handle sign extension for verilator since it expects and
                # unsigned c type
                port_len = len(action.port)
                value = BitVector(value, port_len).as_uint()
            result = [f&#34;top-&gt;{name} = {value};&#34;]
            # Hack to support verilator&#39;s semantics, need to set the register
            # mux values for expected behavior
            if is_reg_poke:
                action.port[-1].path = &#34;out&#34;
                result += self.make_poke(i, action)
                action.port[-1].path = &#34;in&#34;
                result += self.make_poke(i, action)
                if &#34;enable_mux&#34; in action.port[-3].instance_map:
                    mux_inst = action.port[-3].instance_map[&#34;enable_mux&#34;]
                    action.port[-2] = InstanceWrapper(mux_inst, action.port[-3])
                    action.port[-1] = type(mux_inst).I0
                    result += self.make_poke(i, action)
            return result

    def make_print(self, i, action):
        name = verilog_name(action.port.name)
        return [f&#39;printf(&#34;{action.port.debug_name} = &#39;
                f&#39;{action.format_str}\\n&#34;, top-&gt;{name});&#39;]

    def make_expect(self, i, action):
        # For verilator, if an expect is &#34;AnyValue&#34; we don&#39;t need to
        # perform the expect.
        if value_utils.is_any(action.value):
            return []
        if self.verilator_version &gt; 3.874:
            prefix = f&#34;{self.circuit_name}&#34;
        else:
            prefix = f&#34;v&#34;
        if isinstance(action.port, fault.WrappedVerilogInternalPort):
            path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
            name = f&#34;{prefix}-&gt;{path}&#34;
            debug_name = name
        elif isinstance(action.port, SelectPath):
            name = action.port.verilator_path
            if len(action.port) &gt; 2:
                name = f&#34;{prefix}-&gt;&#34; + name
            if self.verilator_version &gt;= 3.856:
                if len(action.port) &gt; 2:
                    self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
            for item in action.port[1:-1]:
                circuit_name = type(item.instance).name
                self.debug_includes.add(f&#34;{circuit_name}&#34;)
            debug_name = action.port[-1].debug_name
        else:
            name = verilog_name(action.port.name)
            debug_name = action.port.debug_name
        value = action.value
        if isinstance(value, actions.Peek):
            if isinstance(value.port, fault.WrappedVerilogInternalPort):
                path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
                value = f&#34;top-&gt;{prefix}-&gt;{path}&#34;
            else:
                value = f&#34;top-&gt;{verilog_name(value.port.name)}&#34;
        elif isinstance(value, PortWrapper):
            if self.verilator_version &gt;= 3.856:
                if len(action.port) &gt; 2:
                    self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
            for item in value.select_path[1:-1]:
                circuit_name = type(item.instance).name
                self.debug_includes.add(f&#34;{circuit_name}&#34;)
            value = f&#34;top-&gt;{prefix}-&gt;&#34; + value.select_path.verilator_path
        elif isinstance(action.port, m.SIntType) and value &lt; 0:
            # Handle sign extension for verilator since it expects and
            # unsigned c type
            port_len = len(action.port)
            value = BitVector(value, port_len).as_uint()

        return [f&#34;my_assert(top-&gt;{name}, {value}, &#34;
                f&#34;{i}, \&#34;{debug_name}\&#34;);&#34;]

    def make_eval(self, i, action):
        return [&#34;top-&gt;eval();&#34;, &#34;main_time++;&#34;, &#34;#if VM_TRACE&#34;,
                &#34;tracer-&gt;dump(main_time);&#34;, &#34;#endif&#34;]

    def make_step(self, i, action):
        name = verilog_name(action.clock.name)
        code = []
        for step in range(action.steps):
            code.append(&#34;top-&gt;eval();&#34;)
            code.append(&#34;main_time++;&#34;)
            code.append(&#34;#if VM_TRACE&#34;)
            code.append(&#34;tracer-&gt;dump(main_time);&#34;)
            code.append(&#34;#endif&#34;)
            code.append(f&#34;top-&gt;{name} ^= 1;&#34;)
        return code

    def generate_code(self, actions, verilator_includes, num_tests, circuit):
        if verilator_includes:
            # Include the top circuit by default
            verilator_includes.insert(
                0, f&#39;{self.circuit_name}&#39;)
        includes = [
            f&#39;&#34;V{self.circuit_name}.h&#34;&#39;,
        ] + [f&#39;&#34;V{self.circuit_name}_{include}.h&#34;&#39; for include in
             verilator_includes] + [
            &#39;&#34;verilated.h&#34;&#39;,
            &#39;&lt;iostream&gt;&#39;,
            &#39;&lt;verilated_vcd_c.h&gt;&#39;,
            &#39;&lt;sys/types.h&gt;&#39;,
            &#39;&lt;sys/stat.h&gt;&#39;,
        ]

        main_body = &#34;&#34;
        for i, action in enumerate(actions):
            code = self.generate_action_code(i, action)
            for line in code:
                main_body += f&#34;  {line}\n&#34;

        for i in range(num_tests):
            main_body += self.add_assumptions(circuit, actions, i)
            code = self.make_eval(i, Eval())
            for line in code:
                main_body += f&#34;  {line}\n&#34;
            main_body += self.add_guarantees(circuit, actions, i)

        includes += [f&#39;&#34;V{self.circuit_name}_{include}.h&#34;&#39; for include in
                     self.debug_includes]

        includes_src = &#34;\n&#34;.join([&#34;#include &#34; + i for i in includes])
        src = src_tpl.format(
            includes=includes_src,
            main_body=main_body,
            circuit_name=self.circuit_name,
        )

        return src

    def run_from_directory(self, cmd):
        return subprocess.call(cmd, cwd=self.directory, shell=True)

    def run(self, actions, verilator_includes=[], num_tests=0,
            _circuit=None):
        driver_file = self.directory / Path(f&#34;{self.circuit_name}_driver.cpp&#34;)
        # Write the verilator driver to file.
        src = self.generate_code(actions, verilator_includes, num_tests,
                                 _circuit)
        with open(driver_file, &#34;w&#34;) as f:
            f.write(src)
        # Run a series of commands: run the Makefile output by verilator, and
        # finally run the executable created by verilator.
        verilator_make_cmd = verilator_utils.verilator_make_cmd(
            self.circuit_name)
        assert not self.run_from_directory(verilator_make_cmd)
        assert not self.run_from_directory(f&#34;./obj_dir/V{self.circuit_name}&#34;)

    def add_assumptions(self, circuit, actions, i):
        main_body = &#34;&#34;
        for port in circuit.interface.ports.values():
            if port.isoutput():
                for assumption in self.assumptions:
                    # TODO: Chained assumptions?
                    assume_port = assumption.port
                    if isinstance(assume_port, SelectPath):
                        assume_port = assume_port[-1]
                    if assume_port is port:
                        pred = assumption.value
                        while True:
                            randval = random_bv(len(assume_port))
                            if pred(randval):
                                break
                        code = self.make_poke(
                            len(actions) + i, Poke(port, randval))
                        for line in code:
                            main_body += f&#34;  {line}\n&#34;
                        break
        return main_body

    def add_guarantees(self, circuit, actions, i):
        main_body = &#34;&#34;
        for name, port in circuit.interface.ports.items():
            if port.isinput():
                for guarantee in self.guarantees:
                    guarantee_port = guarantee.port
                    if isinstance(guarantee_port, SelectPath):
                        guarantee_port = guarantee_port[-1]
                    if guarantee_port is port:
                        # TODO: Support functions too
                        code = utils.get_short_lambda_body_text(guarantee.value)
                        # TODO: More robust symbol replacer on AST
                        for port in circuit.interface.ports:
                            code = code.replace(&#34;and&#34;, &#34;&amp;&amp;&#34;)
                            code = code.replace(port, f&#34;top-&gt;{port}&#34;)
                        main_body += f&#34;&#34;&#34;\
    if (!({code})) {{
      std::cerr &lt;&lt; std::endl;  // end the current line
      std::cerr &lt;&lt; \&#34;Got      : 0x\&#34; &lt;&lt; std::hex &lt;&lt; top-&gt;{name} &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;Expected : {code}&#34; &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;i        : {i}\&#34; &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;Port     : {name}\&#34; &lt;&lt; std::endl;
      #if VM_TRACE
        tracer-&gt;close();
      #endif
      exit(1);
    }}
&#34;&#34;&#34;
        return main_body}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fault.verilator_target.VerilatorTarget.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, circuit, directory=&#39;build/&#39;, flags=[], skip_compile=False, include_verilog_libraries=[], include_directories=[], magma_output=&#39;coreir-verilog&#39;, circuit_name=None, magma_opts={})</span>
</code></dt>
<dd>
<section class="desc"><dl>
<dt><strong><code>Params</code></strong></dt>
<dd>
<p><code>include_verilog_libraries</code>: a list of verilog libraries to include
with the -v flag.
From the verilator docs:
-v <filename>
Verilog library</p>
<p><code>include_directories</code>: a list of directories to include using the
-I flag. From the the verilator docs:
-I<dir>
Directory to search for includes</p>
</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, circuit, directory=&#34;build/&#34;,
             flags=[], skip_compile=False, include_verilog_libraries=[],
             include_directories=[], magma_output=&#34;coreir-verilog&#34;,
             circuit_name=None, magma_opts={}):
    &#34;&#34;&#34;
    Params:
        `include_verilog_libraries`: a list of verilog libraries to include
        with the -v flag.  From the verilator docs:
            -v &lt;filename&gt;              Verilog library

        `include_directories`: a list of directories to include using the
        -I flag. From the the verilator docs:
            -I&lt;dir&gt;                    Directory to search for includes
    &#34;&#34;&#34;
    super().__init__(circuit, circuit_name, directory, skip_compile,
                     include_verilog_libraries, magma_output, magma_opts)
    self.flags = flags
    self.include_directories = include_directories

    # Compile the design using `verilator`
    driver_file = self.directory / Path(f&#34;{self.circuit_name}_driver.cpp&#34;)
    verilator_cmd = verilator_utils.verilator_cmd(
        self.circuit_name, self.verilog_file.name,
        self.include_verilog_libraries, self.include_directories,
        driver_file.name, self.flags)
    if self.run_from_directory(verilator_cmd):
        raise Exception(f&#34;Running verilator cmd {verilator_cmd} failed&#34;)
    self.debug_includes = set()
    verilator_version = subprocess.check_output(&#34;verilator --version&#34;,
                                                shell=True)
    # Need to check version since they changed how internal signal access
    # works
    self.verilator_version = float(verilator_version.split()[1])}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.add_assumptions"><code class="name flex">
<span>def <span class="ident">add_assumptions</span></span>(<span>self, circuit, actions, i)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_assumptions(self, circuit, actions, i):
    main_body = &#34;&#34;
    for port in circuit.interface.ports.values():
        if port.isoutput():
            for assumption in self.assumptions:
                # TODO: Chained assumptions?
                assume_port = assumption.port
                if isinstance(assume_port, SelectPath):
                    assume_port = assume_port[-1]
                if assume_port is port:
                    pred = assumption.value
                    while True:
                        randval = random_bv(len(assume_port))
                        if pred(randval):
                            break
                    code = self.make_poke(
                        len(actions) + i, Poke(port, randval))
                    for line in code:
                        main_body += f&#34;  {line}\n&#34;
                    break
    return main_body}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.add_guarantees"><code class="name flex">
<span>def <span class="ident">add_guarantees</span></span>(<span>self, circuit, actions, i)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">    def add_guarantees(self, circuit, actions, i):
        main_body = &#34;&#34;
        for name, port in circuit.interface.ports.items():
            if port.isinput():
                for guarantee in self.guarantees:
                    guarantee_port = guarantee.port
                    if isinstance(guarantee_port, SelectPath):
                        guarantee_port = guarantee_port[-1]
                    if guarantee_port is port:
                        # TODO: Support functions too
                        code = utils.get_short_lambda_body_text(guarantee.value)
                        # TODO: More robust symbol replacer on AST
                        for port in circuit.interface.ports:
                            code = code.replace(&#34;and&#34;, &#34;&amp;&amp;&#34;)
                            code = code.replace(port, f&#34;top-&gt;{port}&#34;)
                        main_body += f&#34;&#34;&#34;\
    if (!({code})) {{
      std::cerr &lt;&lt; std::endl;  // end the current line
      std::cerr &lt;&lt; \&#34;Got      : 0x\&#34; &lt;&lt; std::hex &lt;&lt; top-&gt;{name} &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;Expected : {code}&#34; &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;i        : {i}\&#34; &lt;&lt; std::endl;
      std::cerr &lt;&lt; \&#34;Port     : {name}\&#34; &lt;&lt; std::endl;
      #if VM_TRACE
        tracer-&gt;close();
      #endif
      exit(1);
    }}
&#34;&#34;&#34;
        return main_body}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.generate_code"><code class="name flex">
<span>def <span class="ident">generate_code</span></span>(<span>self, actions, verilator_includes, num_tests, circuit)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def generate_code(self, actions, verilator_includes, num_tests, circuit):
    if verilator_includes:
        # Include the top circuit by default
        verilator_includes.insert(
            0, f&#39;{self.circuit_name}&#39;)
    includes = [
        f&#39;&#34;V{self.circuit_name}.h&#34;&#39;,
    ] + [f&#39;&#34;V{self.circuit_name}_{include}.h&#34;&#39; for include in
         verilator_includes] + [
        &#39;&#34;verilated.h&#34;&#39;,
        &#39;&lt;iostream&gt;&#39;,
        &#39;&lt;verilated_vcd_c.h&gt;&#39;,
        &#39;&lt;sys/types.h&gt;&#39;,
        &#39;&lt;sys/stat.h&gt;&#39;,
    ]

    main_body = &#34;&#34;
    for i, action in enumerate(actions):
        code = self.generate_action_code(i, action)
        for line in code:
            main_body += f&#34;  {line}\n&#34;

    for i in range(num_tests):
        main_body += self.add_assumptions(circuit, actions, i)
        code = self.make_eval(i, Eval())
        for line in code:
            main_body += f&#34;  {line}\n&#34;
        main_body += self.add_guarantees(circuit, actions, i)

    includes += [f&#39;&#34;V{self.circuit_name}_{include}.h&#34;&#39; for include in
                 self.debug_includes]

    includes_src = &#34;\n&#34;.join([&#34;#include &#34; + i for i in includes])
    src = src_tpl.format(
        includes=includes_src,
        main_body=main_body,
        circuit_name=self.circuit_name,
    )

    return src}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.make_eval"><code class="name flex">
<span>def <span class="ident">make_eval</span></span>(<span>self, i, action)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_eval(self, i, action):
    return [&#34;top-&gt;eval();&#34;, &#34;main_time++;&#34;, &#34;#if VM_TRACE&#34;,
            &#34;tracer-&gt;dump(main_time);&#34;, &#34;#endif&#34;]}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.make_expect"><code class="name flex">
<span>def <span class="ident">make_expect</span></span>(<span>self, i, action)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_expect(self, i, action):
    # For verilator, if an expect is &#34;AnyValue&#34; we don&#39;t need to
    # perform the expect.
    if value_utils.is_any(action.value):
        return []
    if self.verilator_version &gt; 3.874:
        prefix = f&#34;{self.circuit_name}&#34;
    else:
        prefix = f&#34;v&#34;
    if isinstance(action.port, fault.WrappedVerilogInternalPort):
        path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
        name = f&#34;{prefix}-&gt;{path}&#34;
        debug_name = name
    elif isinstance(action.port, SelectPath):
        name = action.port.verilator_path
        if len(action.port) &gt; 2:
            name = f&#34;{prefix}-&gt;&#34; + name
        if self.verilator_version &gt;= 3.856:
            if len(action.port) &gt; 2:
                self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
        for item in action.port[1:-1]:
            circuit_name = type(item.instance).name
            self.debug_includes.add(f&#34;{circuit_name}&#34;)
        debug_name = action.port[-1].debug_name
    else:
        name = verilog_name(action.port.name)
        debug_name = action.port.debug_name
    value = action.value
    if isinstance(value, actions.Peek):
        if isinstance(value.port, fault.WrappedVerilogInternalPort):
            path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
            value = f&#34;top-&gt;{prefix}-&gt;{path}&#34;
        else:
            value = f&#34;top-&gt;{verilog_name(value.port.name)}&#34;
    elif isinstance(value, PortWrapper):
        if self.verilator_version &gt;= 3.856:
            if len(action.port) &gt; 2:
                self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
        for item in value.select_path[1:-1]:
            circuit_name = type(item.instance).name
            self.debug_includes.add(f&#34;{circuit_name}&#34;)
        value = f&#34;top-&gt;{prefix}-&gt;&#34; + value.select_path.verilator_path
    elif isinstance(action.port, m.SIntType) and value &lt; 0:
        # Handle sign extension for verilator since it expects and
        # unsigned c type
        port_len = len(action.port)
        value = BitVector(value, port_len).as_uint()

    return [f&#34;my_assert(top-&gt;{name}, {value}, &#34;
            f&#34;{i}, \&#34;{debug_name}\&#34;);&#34;]}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.make_poke"><code class="name flex">
<span>def <span class="ident">make_poke</span></span>(<span>self, i, action)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_poke(self, i, action):
    if self.verilator_version &gt; 3.874:
        prefix = f&#34;{self.circuit_name}&#34;
    else:
        prefix = f&#34;v&#34;
    if isinstance(action.port, fault.WrappedVerilogInternalPort):
        path = action.port.path.replace(&#34;.&#34;, &#34;-&gt;&#34;)
        name = f&#34;{prefix}-&gt;{path}&#34;
    elif isinstance(action.port, SelectPath):
        name = &#34;&#34;
        if len(action.port) &gt; 2:
            # TODO: Find the version that they changed this, 3.874 is known
            # to use top-&gt;v instead of top-&gt;{circuit_name}
            name += f&#34;{prefix}-&gt;&#34;
        name += action.port.verilator_path
        if len(action.port) &gt; 2:
            self.debug_includes.add(f&#34;{action.port[0].circuit.name}&#34;)
        for item in action.port[1:-1]:
            circuit = type(item.instance)
            circuit_name = circuit.verilog_name
            # Verilator specializes each parametrization into a separate
            # mdoule, this is an attempt to reverse engineer the naming
            # scheme
            if circuit_name == &#34;coreir_reg&#34;:
                circuit_name += &#34;_&#34;
                circuit_name += f&#34;_I{circuit.coreir_configargs[&#39;init&#39;]}&#34;
                circuit_name += f&#34;_W{circuit.coreir_genargs[&#39;width&#39;]}&#34;
            elif circuit_name == &#34;coreir_reg_arst&#34;:
                circuit_name += &#34;_&#34;
                circuit_name += f&#34;_I{circuit.coreir_configargs[&#39;init&#39;]}&#34;
                if circuit.coreir_genargs[&#39;width&#39;] != 1:
                    circuit_name += f&#34;_W{circuit.coreir_genargs[&#39;width&#39;]}&#34;
            self.debug_includes.add(f&#34;{circuit_name}&#34;)
    else:
        name = verilog_name(action.port.name)

    # Special case poking internal registers
    is_reg_poke = isinstance(action.port, SelectPath) and \
        isinstance(action.port[-1], fault.WrappedVerilogInternalPort) \
        and action.port[-1].path == &#34;outReg&#34;

    max_bits = 64 if platform.architecture()[0] == &#34;64bit&#34; else 32
    if isinstance(action.value, BitVector) and \
            action.value.num_bits &gt; max_bits:
        asserts = []
        for i in range(math.ceil(action.value.num_bits / max_bits)):
            value = action.value[i * max_bits:min(
                (i + 1) * max_bits, action.value.num_bits)]
            asserts += [f&#34;top-&gt;{name}[{i}] = {value};&#34;]
        if is_reg_poke:
            raise NotImplementedError()
        return asserts
    else:
        value = action.value
        if isinstance(action.port, m.SIntType) and value &lt; 0:
            # Handle sign extension for verilator since it expects and
            # unsigned c type
            port_len = len(action.port)
            value = BitVector(value, port_len).as_uint()
        result = [f&#34;top-&gt;{name} = {value};&#34;]
        # Hack to support verilator&#39;s semantics, need to set the register
        # mux values for expected behavior
        if is_reg_poke:
            action.port[-1].path = &#34;out&#34;
            result += self.make_poke(i, action)
            action.port[-1].path = &#34;in&#34;
            result += self.make_poke(i, action)
            if &#34;enable_mux&#34; in action.port[-3].instance_map:
                mux_inst = action.port[-3].instance_map[&#34;enable_mux&#34;]
                action.port[-2] = InstanceWrapper(mux_inst, action.port[-3])
                action.port[-1] = type(mux_inst).I0
                result += self.make_poke(i, action)
        return result}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.make_print"><code class="name flex">
<span>def <span class="ident">make_print</span></span>(<span>self, i, action)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_print(self, i, action):
    name = verilog_name(action.port.name)
    return [f&#39;printf(&#34;{action.port.debug_name} = &#39;
            f&#39;{action.format_str}\\n&#34;, top-&gt;{name});&#39;]}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.make_step"><code class="name flex">
<span>def <span class="ident">make_step</span></span>(<span>self, i, action)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_step(self, i, action):
    name = verilog_name(action.clock.name)
    code = []
    for step in range(action.steps):
        code.append(&#34;top-&gt;eval();&#34;)
        code.append(&#34;main_time++;&#34;)
        code.append(&#34;#if VM_TRACE&#34;)
        code.append(&#34;tracer-&gt;dump(main_time);&#34;)
        code.append(&#34;#endif&#34;)
        code.append(f&#34;top-&gt;{name} ^= 1;&#34;)
    return code}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, actions, verilator_includes=[], num_tests=0)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run(self, actions, verilator_includes=[], num_tests=0,
        _circuit=None):
    driver_file = self.directory / Path(f&#34;{self.circuit_name}_driver.cpp&#34;)
    # Write the verilator driver to file.
    src = self.generate_code(actions, verilator_includes, num_tests,
                             _circuit)
    with open(driver_file, &#34;w&#34;) as f:
        f.write(src)
    # Run a series of commands: run the Makefile output by verilator, and
    # finally run the executable created by verilator.
    verilator_make_cmd = verilator_utils.verilator_make_cmd(
        self.circuit_name)
    assert not self.run_from_directory(verilator_make_cmd)
    assert not self.run_from_directory(f&#34;./obj_dir/V{self.circuit_name}&#34;)}</code></pre>
</details>
</dd>
<dt id="fault.verilator_target.VerilatorTarget.run_from_directory"><code class="name flex">
<span>def <span class="ident">run_from_directory</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run_from_directory(self, cmd):
    return subprocess.call(cmd, cwd=self.directory, shell=True)}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fault" href="index.html">fault</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fault.verilator_target.VerilatorTarget" href="verilog_target.html#fault.verilog_target.VerilogTarget">VerilatorTarget</a></code></h4>
<ul class="two-column">
<li><code><a title="fault.verilator_target.VerilatorTarget.__init__" href="#fault.verilator_target.VerilatorTarget.__init__">__init__</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.add_assumptions" href="#fault.verilator_target.VerilatorTarget.add_assumptions">add_assumptions</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.add_guarantees" href="#fault.verilator_target.VerilatorTarget.add_guarantees">add_guarantees</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.generate_code" href="#fault.verilator_target.VerilatorTarget.generate_code">generate_code</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.make_eval" href="#fault.verilator_target.VerilatorTarget.make_eval">make_eval</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.make_expect" href="#fault.verilator_target.VerilatorTarget.make_expect">make_expect</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.make_poke" href="#fault.verilator_target.VerilatorTarget.make_poke">make_poke</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.make_print" href="#fault.verilator_target.VerilatorTarget.make_print">make_print</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.make_step" href="#fault.verilator_target.VerilatorTarget.make_step">make_step</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.run" href="#fault.verilator_target.VerilatorTarget.run">run</a></code></li>
<li><code><a title="fault.verilator_target.VerilatorTarget.run_from_directory" href="#fault.verilator_target.VerilatorTarget.run_from_directory">run_from_directory</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>