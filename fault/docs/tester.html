<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.1" />
<title>fault.tester API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id=^header-]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:1px solid #ddd;margin:1em 0 1em 4ch}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}#index .two-column{column-count:2}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{background:#ffc;font-weight:400;font-size:.8em;width:11em;text-transform:uppercase;padding:0px 8px;border:1px solid #fd6;border-radius:5px;cursor:pointer}.source summary:hover{background:#fe9 !important}.source[open] summary{background:#fda}.source pre{max-height:500px;overflow-y:scroll;margin-bottom:15px}.hlist{list-syle:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink;]</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>fault.tester</code> module</h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import magma as m
import fault.actions as actions
from fault.magma_simulator_target import MagmaSimulatorTarget
from fault.logging import warning
from fault.vector_builder import VectorBuilder
from fault.value_utils import make_value
from fault.verilator_target import VerilatorTarget
from fault.system_verilog_target import SystemVerilogTarget
from fault.actions import Poke, Expect, Step, Print
from fault.circuit_utils import check_interface_is_subset
from fault.wrapper import CircuitWrapper, PortWrapper, InstanceWrapper
import copy


class Tester:
    &#34;&#34;&#34;
    The fault `Tester` object provides a mechanism in Python to construct tests
    for magma circuits.  The `Tester` is instantiated with a specific magma
    circuit and provides an API for performing actions on the circuit
    interface.

    ## Actions
        * tester_inst.poke(port, value) - set `port` to be `value`
        * tester_inst.eval() - have the backend simulator evaluate the DUT to
            propogate any poked inputs (this happens implicitly on every poke
            for event driven simulators such as ncsim/vcs, but not for
            verilator)
        * tester_inst.expect(port, value) - expect `port` to equal `value`
        * tester_inst.peek(port) - returns a symbolic handle to the port&#39;s
            current value (current in the context of the tester_inst&#39;s recorded
            action sequence)
        * tester_inst.step(n) - Step the clock `n` times (defaults to 1)
        * tester_inst.print(port) - Print out the value of `port`


    Tester supports multiple simulation environments (backends) for the actual
    execution of tests.

    ## Backend Targets
        * verilator
        * ncsim
        * vcs
    &#34;&#34;&#34;

    __test__ = False  # Tell pytest to skip this class for discovery

    def __init__(self, circuit: m.Circuit, clock: m.ClockType = None,
                 default_print_format_str: str = &#34;%x&#34;):
        &#34;&#34;&#34;
        `circuit`: the device under test (a magma circuit)
        `clock`: optional, a port from `circuit` corresponding to the clock
        `default_print_format_str`: optional, this sets the default format
            string used for the `print` method
        &#34;&#34;&#34;
        self._circuit = circuit
        self.actions = []
        if clock is not None and not isinstance(clock, m.ClockType):
            raise TypeError(f&#34;Expected clock port: {clock, type(clock)}&#34;)
        self.clock = clock
        self.default_print_format_str = default_print_format_str
        self.targets = {}
        # For public verilator modules
        self.verilator_includes = []

    def make_target(self, target: str, **kwargs):
        &#34;&#34;&#34;
        Called with the string `target`, returns an instance of the
        corresponding target object.

        Supported values of target: &#34;verilator&#34;, &#34;coreir&#34;, &#34;python&#34;,
            &#34;system-verilog&#34;
        &#34;&#34;&#34;
        if target == &#34;verilator&#34;:
            return VerilatorTarget(self._circuit, **kwargs)
        elif target == &#34;coreir&#34;:
            return MagmaSimulatorTarget(self._circuit, clock=self.clock,
                                        backend=&#39;coreir&#39;, **kwargs)
        elif target == &#34;python&#34;:
            return MagmaSimulatorTarget(self._circuit, clock=self.clock,
                                        backend=&#39;python&#39;, **kwargs)
        elif target == &#34;system-verilog&#34;:
            return SystemVerilogTarget(self._circuit, **kwargs)
        raise NotImplementedError(target)

    def poke(self, port, value):
        &#34;&#34;&#34;
        Set `port` to be `value`
        &#34;&#34;&#34;
        if isinstance(port, m.TupleType):
            for p, v in zip(port, value):
                self.poke(p, v)
        else:
            value = make_value(port, value)
            self.actions.append(actions.Poke(port, value))

    def peek(self, port):
        &#34;&#34;&#34;
        Returns a symbolic handle to the current value of `port`
        &#34;&#34;&#34;
        return actions.Peek(port)

    def print(self, port, format_str=None):
        &#34;&#34;&#34;
        Print out the current value of `port`.

        If `format_str` is not specified, it will use
        `self.default_print_format_str`
        &#34;&#34;&#34;
        if format_str is None:
            format_str = self.default_print_format_str
        self.actions.append(actions.Print(port, format_str))

    def expect(self, port, value):
        &#34;&#34;&#34;
        Expect the current value of `port` to be `value`
        &#34;&#34;&#34;
        is_peek = isinstance(value, actions.Peek)
        is_port_wrapper = isinstance(value, PortWrapper)
        if not (is_peek or is_port_wrapper):
            value = make_value(port, value)
        self.actions.append(actions.Expect(port, value))

    def eval(self):
        &#34;&#34;&#34;
        Evaluate the DUT given the current input port values
        &#34;&#34;&#34;
        self.actions.append(actions.Eval())

    def step(self, steps=1):
        &#34;&#34;&#34;
        Step the clock `steps` times.
        &#34;&#34;&#34;
        if self.clock is None:
            raise RuntimeError(&#34;Stepping tester without a clock (did you &#34;
                               &#34;specify a clock during initialization?)&#34;)
        self.actions.append(actions.Step(self.clock, steps))

    def serialize(self):
        &#34;&#34;&#34;
        Serialize the action sequence into a set of test vectors
        &#34;&#34;&#34;
        builder = VectorBuilder(self._circuit)
        for action in self.actions:
            builder.process(action)
        return builder.vectors

    def compile(self, target=&#34;verilator&#34;, **kwargs):
        &#34;&#34;&#34;
        Create an instance of the target backend.

        For the verilator backend, this will run verilator to compile the C++
        model.  This allows the user to separate the logic to compile the DUT
        into the model and run the actual tests (for example, if the user
        wants to compile a DUT once and run multiple tests with the same model,
        this avoids having to call verilator multiple times)
        &#34;&#34;&#34;
        self.targets[target] = self.make_target(target, **kwargs)

    def run(self, target=&#34;verilator&#34;):
        &#34;&#34;&#34;
        Run the current action sequence using the specified `target`.  The user
        should call `compile` with `target` before calling `run`.
        &#34;&#34;&#34;
        try:
            if target == &#34;verilator&#34;:
                self.targets[target].run(self.actions, self.verilator_includes)
            else:
                self.targets[target].run(self.actions)
        except KeyError:
            raise Exception(f&#34;Could not find target={target}, did you compile&#34;
                            &#34; it first?&#34;)

    def compile_and_run(self, target=&#34;verilator&#34;, **kwargs):
        &#34;&#34;&#34;
        Compile and run the current action sequence using `target`
        &#34;&#34;&#34;
        self.compile(target, **kwargs)
        self.run(target)

    def retarget(self, new_circuit, clock=None):
        &#34;&#34;&#34;
        Generates a new instance of the Tester object that targets
        `new_circuit`. This allows you to copy a set of actions for a new
        circuit with the same interface (or an interface that is a super set of
        self._circuit)
        &#34;&#34;&#34;
        # Check that the interface of self._circuit is a subset of new_circuit
        check_interface_is_subset(self._circuit, new_circuit)

        new_tester = Tester(new_circuit, clock, self.default_print_format_str)
        new_tester.actions = [action.retarget(new_circuit, clock) for action in
                              self.actions]
        return new_tester

    def zero_inputs(self):
        &#34;&#34;&#34;
        Set all the input ports to 0, useful for intiializing everything to a
        known value
        &#34;&#34;&#34;
        for name, port in self._circuit.IO.ports.items():
            if port.isinput():
                self.poke(self._circuit.interface.ports[name], 0)

    def clear(self):
        &#34;&#34;&#34;
        Reset the tester by removing any existing actions. Useful for reusing a
        Tester (e.g. one with verilator already compiled).
        &#34;&#34;&#34;
        self.actions = []

    def __str__(self):
        &#34;&#34;&#34;
        Returns a string containing a list of the recorded actions stored in
        `self.actions`
        &#34;&#34;&#34;
        s = object.__str__(self) + &#34;\n&#34;
        s += &#34;Actions:\n&#34;
        for i, action in enumerate(self.actions):
            s += f&#34;    {i}: {action}\n&#34;
        return s

    def verilator_include(self, module_name):
        self.verilator_includes.append(module_name)

    @property
    def circuit(self):
        return CircuitWrapper(self._circuit, self)}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fault.tester.Tester"><code class="flex name class">
<span>class <span class="ident">Tester</span></span>
</code></dt>
<dd>
<section class="desc"><p>The fault <a title="fault.tester.Tester" href="#fault.tester.Tester"><code>Tester</code></a> object provides a mechanism in Python to construct tests
for magma circuits.
The <a title="fault.tester.Tester" href="#fault.tester.Tester"><code>Tester</code></a> is instantiated with a specific magma
circuit and provides an API for performing actions on the circuit
interface.</p>
<h2 id="actions">Actions</h2>
<pre><code>* tester_inst.poke(port, value) - set `port` to be `value`
* tester_inst.eval() - have the backend simulator evaluate the DUT to
    propogate any poked inputs (this happens implicitly on every poke
    for event driven simulators such as ncsim/vcs, but not for
    verilator)
* tester_inst.expect(port, value) - expect `port` to equal `value`
* tester_inst.peek(port) - returns a symbolic handle to the port's
    current value (current in the context of the tester_inst's recorded
    action sequence)
* tester_inst.step(n) - Step the clock `n` times (defaults to 1)
* tester_inst.print(port) - Print out the value of `port`
</code></pre>
<p>Tester supports multiple simulation environments (backends) for the actual
execution of tests.</p>
<h2 id="backend-targets">Backend Targets</h2>
<pre><code>* verilator
* ncsim
* vcs
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Tester:
    &#34;&#34;&#34;
    The fault `Tester` object provides a mechanism in Python to construct tests
    for magma circuits.  The `Tester` is instantiated with a specific magma
    circuit and provides an API for performing actions on the circuit
    interface.

    ## Actions
        * tester_inst.poke(port, value) - set `port` to be `value`
        * tester_inst.eval() - have the backend simulator evaluate the DUT to
            propogate any poked inputs (this happens implicitly on every poke
            for event driven simulators such as ncsim/vcs, but not for
            verilator)
        * tester_inst.expect(port, value) - expect `port` to equal `value`
        * tester_inst.peek(port) - returns a symbolic handle to the port&#39;s
            current value (current in the context of the tester_inst&#39;s recorded
            action sequence)
        * tester_inst.step(n) - Step the clock `n` times (defaults to 1)
        * tester_inst.print(port) - Print out the value of `port`


    Tester supports multiple simulation environments (backends) for the actual
    execution of tests.

    ## Backend Targets
        * verilator
        * ncsim
        * vcs
    &#34;&#34;&#34;

    __test__ = False  # Tell pytest to skip this class for discovery

    def __init__(self, circuit: m.Circuit, clock: m.ClockType = None,
                 default_print_format_str: str = &#34;%x&#34;):
        &#34;&#34;&#34;
        `circuit`: the device under test (a magma circuit)
        `clock`: optional, a port from `circuit` corresponding to the clock
        `default_print_format_str`: optional, this sets the default format
            string used for the `print` method
        &#34;&#34;&#34;
        self._circuit = circuit
        self.actions = []
        if clock is not None and not isinstance(clock, m.ClockType):
            raise TypeError(f&#34;Expected clock port: {clock, type(clock)}&#34;)
        self.clock = clock
        self.default_print_format_str = default_print_format_str
        self.targets = {}
        # For public verilator modules
        self.verilator_includes = []

    def make_target(self, target: str, **kwargs):
        &#34;&#34;&#34;
        Called with the string `target`, returns an instance of the
        corresponding target object.

        Supported values of target: &#34;verilator&#34;, &#34;coreir&#34;, &#34;python&#34;,
            &#34;system-verilog&#34;
        &#34;&#34;&#34;
        if target == &#34;verilator&#34;:
            return VerilatorTarget(self._circuit, **kwargs)
        elif target == &#34;coreir&#34;:
            return MagmaSimulatorTarget(self._circuit, clock=self.clock,
                                        backend=&#39;coreir&#39;, **kwargs)
        elif target == &#34;python&#34;:
            return MagmaSimulatorTarget(self._circuit, clock=self.clock,
                                        backend=&#39;python&#39;, **kwargs)
        elif target == &#34;system-verilog&#34;:
            return SystemVerilogTarget(self._circuit, **kwargs)
        raise NotImplementedError(target)

    def poke(self, port, value):
        &#34;&#34;&#34;
        Set `port` to be `value`
        &#34;&#34;&#34;
        if isinstance(port, m.TupleType):
            for p, v in zip(port, value):
                self.poke(p, v)
        else:
            value = make_value(port, value)
            self.actions.append(actions.Poke(port, value))

    def peek(self, port):
        &#34;&#34;&#34;
        Returns a symbolic handle to the current value of `port`
        &#34;&#34;&#34;
        return actions.Peek(port)

    def print(self, port, format_str=None):
        &#34;&#34;&#34;
        Print out the current value of `port`.

        If `format_str` is not specified, it will use
        `self.default_print_format_str`
        &#34;&#34;&#34;
        if format_str is None:
            format_str = self.default_print_format_str
        self.actions.append(actions.Print(port, format_str))

    def expect(self, port, value):
        &#34;&#34;&#34;
        Expect the current value of `port` to be `value`
        &#34;&#34;&#34;
        is_peek = isinstance(value, actions.Peek)
        is_port_wrapper = isinstance(value, PortWrapper)
        if not (is_peek or is_port_wrapper):
            value = make_value(port, value)
        self.actions.append(actions.Expect(port, value))

    def eval(self):
        &#34;&#34;&#34;
        Evaluate the DUT given the current input port values
        &#34;&#34;&#34;
        self.actions.append(actions.Eval())

    def step(self, steps=1):
        &#34;&#34;&#34;
        Step the clock `steps` times.
        &#34;&#34;&#34;
        if self.clock is None:
            raise RuntimeError(&#34;Stepping tester without a clock (did you &#34;
                               &#34;specify a clock during initialization?)&#34;)
        self.actions.append(actions.Step(self.clock, steps))

    def serialize(self):
        &#34;&#34;&#34;
        Serialize the action sequence into a set of test vectors
        &#34;&#34;&#34;
        builder = VectorBuilder(self._circuit)
        for action in self.actions:
            builder.process(action)
        return builder.vectors

    def compile(self, target=&#34;verilator&#34;, **kwargs):
        &#34;&#34;&#34;
        Create an instance of the target backend.

        For the verilator backend, this will run verilator to compile the C++
        model.  This allows the user to separate the logic to compile the DUT
        into the model and run the actual tests (for example, if the user
        wants to compile a DUT once and run multiple tests with the same model,
        this avoids having to call verilator multiple times)
        &#34;&#34;&#34;
        self.targets[target] = self.make_target(target, **kwargs)

    def run(self, target=&#34;verilator&#34;):
        &#34;&#34;&#34;
        Run the current action sequence using the specified `target`.  The user
        should call `compile` with `target` before calling `run`.
        &#34;&#34;&#34;
        try:
            if target == &#34;verilator&#34;:
                self.targets[target].run(self.actions, self.verilator_includes)
            else:
                self.targets[target].run(self.actions)
        except KeyError:
            raise Exception(f&#34;Could not find target={target}, did you compile&#34;
                            &#34; it first?&#34;)

    def compile_and_run(self, target=&#34;verilator&#34;, **kwargs):
        &#34;&#34;&#34;
        Compile and run the current action sequence using `target`
        &#34;&#34;&#34;
        self.compile(target, **kwargs)
        self.run(target)

    def retarget(self, new_circuit, clock=None):
        &#34;&#34;&#34;
        Generates a new instance of the Tester object that targets
        `new_circuit`. This allows you to copy a set of actions for a new
        circuit with the same interface (or an interface that is a super set of
        self._circuit)
        &#34;&#34;&#34;
        # Check that the interface of self._circuit is a subset of new_circuit
        check_interface_is_subset(self._circuit, new_circuit)

        new_tester = Tester(new_circuit, clock, self.default_print_format_str)
        new_tester.actions = [action.retarget(new_circuit, clock) for action in
                              self.actions]
        return new_tester

    def zero_inputs(self):
        &#34;&#34;&#34;
        Set all the input ports to 0, useful for intiializing everything to a
        known value
        &#34;&#34;&#34;
        for name, port in self._circuit.IO.ports.items():
            if port.isinput():
                self.poke(self._circuit.interface.ports[name], 0)

    def clear(self):
        &#34;&#34;&#34;
        Reset the tester by removing any existing actions. Useful for reusing a
        Tester (e.g. one with verilator already compiled).
        &#34;&#34;&#34;
        self.actions = []

    def __str__(self):
        &#34;&#34;&#34;
        Returns a string containing a list of the recorded actions stored in
        `self.actions`
        &#34;&#34;&#34;
        s = object.__str__(self) + &#34;\n&#34;
        s += &#34;Actions:\n&#34;
        for i, action in enumerate(self.actions):
            s += f&#34;    {i}: {action}\n&#34;
        return s

    def verilator_include(self, module_name):
        self.verilator_includes.append(module_name)

    @property
    def circuit(self):
        return CircuitWrapper(self._circuit, self)}</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fault.tester.Tester.circuit"><code class="name">var <span class="ident">circuit</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def circuit(self):
    return CircuitWrapper(self._circuit, self)}</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fault.tester.Tester.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, circuit, clock=None, default_print_format_str=&#39;%x&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p><code>circuit</code>: the device under test (a magma circuit)
<code>clock</code>: optional, a port from <code>circuit</code> corresponding to the clock
<code>default_print_format_str</code>: optional, this sets the default format
string used for the <code>print</code> method</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, circuit: m.Circuit, clock: m.ClockType = None,
             default_print_format_str: str = &#34;%x&#34;):
    &#34;&#34;&#34;
    `circuit`: the device under test (a magma circuit)
    `clock`: optional, a port from `circuit` corresponding to the clock
    `default_print_format_str`: optional, this sets the default format
        string used for the `print` method
    &#34;&#34;&#34;
    self._circuit = circuit
    self.actions = []
    if clock is not None and not isinstance(clock, m.ClockType):
        raise TypeError(f&#34;Expected clock port: {clock, type(clock)}&#34;)
    self.clock = clock
    self.default_print_format_str = default_print_format_str
    self.targets = {}
    # For public verilator modules
    self.verilator_includes = []}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Reset the tester by removing any existing actions. Useful for reusing a
Tester (e.g. one with verilator already compiled).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Reset the tester by removing any existing actions. Useful for reusing a
    Tester (e.g. one with verilator already compiled).
    &#34;&#34;&#34;
    self.actions = []}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, target=&#39;verilator&#39;, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create an instance of the target backend.</p>
<p>For the verilator backend, this will run verilator to compile the C++
model.
This allows the user to separate the logic to compile the DUT
into the model and run the actual tests (for example, if the user
wants to compile a DUT once and run multiple tests with the same model,
this avoids having to call verilator multiple times)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compile(self, target=&#34;verilator&#34;, **kwargs):
    &#34;&#34;&#34;
    Create an instance of the target backend.

    For the verilator backend, this will run verilator to compile the C++
    model.  This allows the user to separate the logic to compile the DUT
    into the model and run the actual tests (for example, if the user
    wants to compile a DUT once and run multiple tests with the same model,
    this avoids having to call verilator multiple times)
    &#34;&#34;&#34;
    self.targets[target] = self.make_target(target, **kwargs)}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.compile_and_run"><code class="name flex">
<span>def <span class="ident">compile_and_run</span></span>(<span>self, target=&#39;verilator&#39;, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Compile and run the current action sequence using <code>target</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compile_and_run(self, target=&#34;verilator&#34;, **kwargs):
    &#34;&#34;&#34;
    Compile and run the current action sequence using `target`
    &#34;&#34;&#34;
    self.compile(target, **kwargs)
    self.run(target)}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Evaluate the DUT given the current input port values</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def eval(self):
    &#34;&#34;&#34;
    Evaluate the DUT given the current input port values
    &#34;&#34;&#34;
    self.actions.append(actions.Eval())}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.expect"><code class="name flex">
<span>def <span class="ident">expect</span></span>(<span>self, port, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Expect the current value of <code>port</code> to be <code>value</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def expect(self, port, value):
    &#34;&#34;&#34;
    Expect the current value of `port` to be `value`
    &#34;&#34;&#34;
    is_peek = isinstance(value, actions.Peek)
    is_port_wrapper = isinstance(value, PortWrapper)
    if not (is_peek or is_port_wrapper):
        value = make_value(port, value)
    self.actions.append(actions.Expect(port, value))}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.make_target"><code class="name flex">
<span>def <span class="ident">make_target</span></span>(<span>self, target, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Called with the string <code>target</code>, returns an instance of the
corresponding target object.</p>
<p>Supported values of target: "verilator", "coreir", "python",
"system-verilog"</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def make_target(self, target: str, **kwargs):
    &#34;&#34;&#34;
    Called with the string `target`, returns an instance of the
    corresponding target object.

    Supported values of target: &#34;verilator&#34;, &#34;coreir&#34;, &#34;python&#34;,
        &#34;system-verilog&#34;
    &#34;&#34;&#34;
    if target == &#34;verilator&#34;:
        return VerilatorTarget(self._circuit, **kwargs)
    elif target == &#34;coreir&#34;:
        return MagmaSimulatorTarget(self._circuit, clock=self.clock,
                                    backend=&#39;coreir&#39;, **kwargs)
    elif target == &#34;python&#34;:
        return MagmaSimulatorTarget(self._circuit, clock=self.clock,
                                    backend=&#39;python&#39;, **kwargs)
    elif target == &#34;system-verilog&#34;:
        return SystemVerilogTarget(self._circuit, **kwargs)
    raise NotImplementedError(target)}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, port)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a symbolic handle to the current value of <code>port</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def peek(self, port):
    &#34;&#34;&#34;
    Returns a symbolic handle to the current value of `port`
    &#34;&#34;&#34;
    return actions.Peek(port)}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.poke"><code class="name flex">
<span>def <span class="ident">poke</span></span>(<span>self, port, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set <code>port</code> to be <code>value</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def poke(self, port, value):
    &#34;&#34;&#34;
    Set `port` to be `value`
    &#34;&#34;&#34;
    if isinstance(port, m.TupleType):
        for p, v in zip(port, value):
            self.poke(p, v)
    else:
        value = make_value(port, value)
        self.actions.append(actions.Poke(port, value))}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, port, format_str=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Print out the current value of <code>port</code>.</p>
<p>If <code>format_str</code> is not specified, it will use
<code>self.default_print_format_str</code></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def print(self, port, format_str=None):
    &#34;&#34;&#34;
    Print out the current value of `port`.

    If `format_str` is not specified, it will use
    `self.default_print_format_str`
    &#34;&#34;&#34;
    if format_str is None:
        format_str = self.default_print_format_str
    self.actions.append(actions.Print(port, format_str))}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.retarget"><code class="name flex">
<span>def <span class="ident">retarget</span></span>(<span>self, new_circuit, clock=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a new instance of the Tester object that targets
<code>new_circuit</code>. This allows you to copy a set of actions for a new
circuit with the same interface (or an interface that is a super set of
self._circuit)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def retarget(self, new_circuit, clock=None):
    &#34;&#34;&#34;
    Generates a new instance of the Tester object that targets
    `new_circuit`. This allows you to copy a set of actions for a new
    circuit with the same interface (or an interface that is a super set of
    self._circuit)
    &#34;&#34;&#34;
    # Check that the interface of self._circuit is a subset of new_circuit
    check_interface_is_subset(self._circuit, new_circuit)

    new_tester = Tester(new_circuit, clock, self.default_print_format_str)
    new_tester.actions = [action.retarget(new_circuit, clock) for action in
                          self.actions]
    return new_tester}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, target=&#39;verilator&#39;)</span>
</code></dt>
<dd>
<section class="desc"><p>Run the current action sequence using the specified <code>target</code>.
The user
should call <code>compile</code> with <code>target</code> before calling <code>run</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def run(self, target=&#34;verilator&#34;):
    &#34;&#34;&#34;
    Run the current action sequence using the specified `target`.  The user
    should call `compile` with `target` before calling `run`.
    &#34;&#34;&#34;
    try:
        if target == &#34;verilator&#34;:
            self.targets[target].run(self.actions, self.verilator_includes)
        else:
            self.targets[target].run(self.actions)
    except KeyError:
        raise Exception(f&#34;Could not find target={target}, did you compile&#34;
                        &#34; it first?&#34;)}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Serialize the action sequence into a set of test vectors</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def serialize(self):
    &#34;&#34;&#34;
    Serialize the action sequence into a set of test vectors
    &#34;&#34;&#34;
    builder = VectorBuilder(self._circuit)
    for action in self.actions:
        builder.process(action)
    return builder.vectors}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, steps=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Step the clock <code>steps</code> times.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def step(self, steps=1):
    &#34;&#34;&#34;
    Step the clock `steps` times.
    &#34;&#34;&#34;
    if self.clock is None:
        raise RuntimeError(&#34;Stepping tester without a clock (did you &#34;
                           &#34;specify a clock during initialization?)&#34;)
    self.actions.append(actions.Step(self.clock, steps))}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.verilator_include"><code class="name flex">
<span>def <span class="ident">verilator_include</span></span>(<span>self, module_name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def verilator_include(self, module_name):
    self.verilator_includes.append(module_name)}</code></pre>
</details>
</dd>
<dt id="fault.tester.Tester.zero_inputs"><code class="name flex">
<span>def <span class="ident">zero_inputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Set all the input ports to 0, useful for intiializing everything to a
known value</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def zero_inputs(self):
    &#34;&#34;&#34;
    Set all the input ports to 0, useful for intiializing everything to a
    known value
    &#34;&#34;&#34;
    for name, port in self._circuit.IO.ports.items():
        if port.isinput():
            self.poke(self._circuit.interface.ports[name], 0)}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fault" href="index.html">fault</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fault.tester.Tester" href="#fault.tester.Tester">Tester</a></code></h4>
<ul class="two-column">
<li><code><a title="fault.tester.Tester.__init__" href="#fault.tester.Tester.__init__">__init__</a></code></li>
<li><code><a title="fault.tester.Tester.circuit" href="#fault.tester.Tester.circuit">circuit</a></code></li>
<li><code><a title="fault.tester.Tester.clear" href="#fault.tester.Tester.clear">clear</a></code></li>
<li><code><a title="fault.tester.Tester.compile" href="#fault.tester.Tester.compile">compile</a></code></li>
<li><code><a title="fault.tester.Tester.compile_and_run" href="#fault.tester.Tester.compile_and_run">compile_and_run</a></code></li>
<li><code><a title="fault.tester.Tester.eval" href="#fault.tester.Tester.eval">eval</a></code></li>
<li><code><a title="fault.tester.Tester.expect" href="#fault.tester.Tester.expect">expect</a></code></li>
<li><code><a title="fault.tester.Tester.make_target" href="#fault.tester.Tester.make_target">make_target</a></code></li>
<li><code><a title="fault.tester.Tester.peek" href="#fault.tester.Tester.peek">peek</a></code></li>
<li><code><a title="fault.tester.Tester.poke" href="#fault.tester.Tester.poke">poke</a></code></li>
<li><code><a title="fault.tester.Tester.print" href="#fault.tester.Tester.print">print</a></code></li>
<li><code><a title="fault.tester.Tester.retarget" href="#fault.tester.Tester.retarget">retarget</a></code></li>
<li><code><a title="fault.tester.Tester.run" href="#fault.tester.Tester.run">run</a></code></li>
<li><code><a title="fault.tester.Tester.serialize" href="#fault.tester.Tester.serialize">serialize</a></code></li>
<li><code><a title="fault.tester.Tester.step" href="#fault.tester.Tester.step">step</a></code></li>
<li><code><a title="fault.tester.Tester.verilator_include" href="#fault.tester.Tester.verilator_include">verilator_include</a></code></li>
<li><code><a title="fault.tester.Tester.zero_inputs" href="#fault.tester.Tester.zero_inputs">zero_inputs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>