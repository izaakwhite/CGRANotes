#include "coreir.h"

using namespace CoreIR;
using namespace std;

int main() {

  Context* c = newContext();
  Namespace* global = c->getGlobal();

  //Now lets make our counter as a generator.
  //We want our counter to be parameterized by a width and to be able to specify whether to have an 'en' port. The former can just be an int, and the latter a bool called 'has_en'
  //Lets create our own set of Params for these.
  Params counterParams({
      {"width",c->Int()},
      {"has_en",c->Bool()}
  });

  //Instead of defining a type, now we need to define a way to determine the type as a function of the counter Params (width and has_en). This function will run the moment that the generator is instanced with the generator parameters. This allows CoreIR to statically type check all instances and connections.
  TypeGen* counterTypeGen = global->newTypeGen(
    "CounterTypeGen", //name of typegen
    counterParams, //Params required for typegen
    [](Context* c, Values genargs) { //lambda for generating the type
      Value* widthArg = genargs.at("width"); //Checking for valid args is already done for you
      uint width = widthArg->get<int>(); //get function to extract the arg value.
      bool has_en = genargs.at("has_en")->get<bool>(); //get function to extract the arg value.
      RecordParams counterIO = {
        {"out",c->Array(width,c->Bit())}, //Note: Array is parameterized by width now
        {"clk",c->Named("coreir.clkIn")},
      };
      //We can now dynamically add the port 'en'
      if (has_en) {
        counterIO.push_back({"en",c->BitIn()});
      }
      return c->Record(counterIO);
    } //end lambda
  ); //end newTypeGen
  ASSERT(global->hasTypeGen("CounterTypeGen"),"Can check for typegens in namespaces");

  //We can test the typeGen function that we just created.
  Type* testType = counterTypeGen->getType({{"width",Const::make(c,7)},{"has_en",Const::make(c,false)}});
  //This should have created a type with just an 'out' port and a 'clk' port
  ASSERT(testType = c->Record({{"out",c->Array(7,c->Bit())},{"clk",c->Named("coreir.clkIn")}}),"Types should be the same!");

  //Now lets create a generator for our counter.
  Generator* counter = global->newGeneratorDecl("counter",counterTypeGen,counterParams);
  //The third argument is the counter parameters. This needs to be a superset of the parameters used for the typegen.
  //The Generator that we just created currently has the ability to create a module, but not any module definition. We will see how to add the ability to generate module generations below.'
  
  //Lets now use our newly created Generator in some top module. 
  //Now lets test this by instancing a few counters.
  Module* top = global->newModuleDecl("counterTestBench",c->Record({{"clk",c->Named("coreir.clkIn")}}));
  ModuleDef* topdef = top->newModuleDef();
    //The first counter will be 32 bits and not have an enable
    Values count0Args = {{"width",Const::make(c,32)}, {"has_en",Const::make(c,false)}};
    //First we are creating the module (but not the defintion!) by passing in our genargs to the generator. 
    Module* count0Module = counter->getModule(count0Args);
    //And then we are instancing the module.
    topdef->addInstance("count0",count0Module);

    //You can introspect the count0Module to see that it was a generated Module. 
    ASSERT(count0Module->isGenerated()==true,"count0Module was definitely generated");
    ASSERT(count0Module->getGenerator()==counter,"count0Module was generated by counter");
    ASSERT(count0Module->getGenArgs()==count0Args,"count0Module was generated with the correct args");

    //Now lets instance a second counter that does have an 'en'
    //Remember, the following command is simply syntax sugar for the above commands
    topdef->addInstance("count1","global.counter",{{"width",Const::make(c,12)}, {"has_en",Const::make(c,true)}});


    //Lets drive the enable of the counter 
    topdef->connect("count0.out.31","count1.en"); //Connect bit 31 of 'count0' to en of 'count1'
    //And connect the clocks
    topdef->connect("self.clk","count0.clk");
    topdef->connect("self.clk","count1.clk");
  top->setDef(topdef);

  //We now have a circuit with instances of our counter. This is a completely valid circuit even though the counters have no definition!
  //We can now pretty print our top module with the counter instantiations.
  top->print();
  //And verify everything is connected.
  c->runPasses({"verifyconnectivity --onlyinputs"});

  
  //We can now provide (or link) some definitions for our counter.
  //The first way to do that is we can provide defintions for specific versions of the counter.
  //Lets implement the defintion for count0 (width=32, has_en=false). This is like specialization.
  //We do this in the exact same way as before (very similar to hellomodule.cpp)
  ModuleDef* c0def = count0Module->newModuleDef();
  {
    Values widthArg = {{"width",Const::make(c,32)}};
    c0def->addInstance("ai","coreir.add",widthArg);
    c0def->addInstance("ci","coreir.const",widthArg,{{"value",Const::make(c,32,1)}});
    //coreir.reg just has a simple 'in','clk,'out' interface
    c0def->addInstance("ri","coreir.reg",widthArg);
    
    c0def->connect("self.clk","ri.clk");
    c0def->connect("ci.out","ai.in0");
    c0def->connect("ai.out","ri.in");
    c0def->connect("ri.out","ai.in1");
    c0def->connect("ri.out","self.out");
  }
  count0Module->setDef(c0def);
  //We can now see that count0Module has a definition
  ASSERT(count0Module->hasDef(),"Has def!");
  count0Module->print();
  
  
  //Now lets define our generator function. I am going to use a lambda similar to how we did the typegen, but you could pass in
  //  a normal function with the same type signature.
  counter->setGeneratorDefFromFun([](Context* c, Values genargs,ModuleDef* def) {
    //ModuleDef* def : The circuit you are defining.
    //Values genargs: The arguments supplied to the instance of the counter.
    
    //We can basically use toString() on almost any coreir class
    cout << "  IN GENERATOR, genargs passed into counter: " << toString(genargs) << endl;
    //Similar to the typegen, lets extract the width and has_en values
    uint width = genargs.at("width")->get<int>();
    bool has_en = genargs.at("has_en")->get<bool>();
     
    //For our width, we can use the width that was passed into the generator.
    Values wArg({{"width",Const::make(c,width)}});
    def->addInstance("ai","coreir.add",wArg);
    def->addInstance("ci","coreir.const",wArg,{{"value",Const::make(c,width,1)}});
    
    //For the register, note that we can direclty pass in the 'has_en' into the mantle.reg's 'has_en' argument
    def->addInstance("ri","mantle.reg",{{"width",Const::make(c,width)},{"has_en",Const::make(c,has_en)}});
    
    //Connections
    //Only connect the 'en' if we actually have an enable
    if (has_en) {
      def->connect("self.en","ri.en");
    }
    def->connect("self.clk","ri.clk");
    def->connect("ci.out","ai.in0");
    def->connect("ai.out","ri.in");
    def->connect("ri.out","ai.in1");
    def->connect("ri.out","self.out");
  }); //end lambda, end function
  
  
  //Lets find the instance from top called "count1"
  ASSERT(topdef->getInstances().count("count1"),"This should have the instance!");
  //getInstances is just returns a map<string,Instance*>
  Instance* count1 = topdef->getInstances().at("count1");
  
  //Lets get the Module which it is instancing. This should be our generated counter.
  Module* count1Module = count1->getModuleRef();
  ASSERT(count1Module->isGenerated()==true,"count1Module was definitely generated");
  ASSERT(count1Module->getGenerator()==counter,"count1Module was generated by counter");
  
  //We have a generic function to compute the defintion, but we have not actualized it yet.
  ASSERT(count1Module->hasDef()==false,"No definition yet");
  
  //In order to actualize it, we need to actually run the generator.
  cout << "Running the generator for count1Module" << endl;
  bool ranGenCount1 = count1Module->runGenerator();
  ASSERT(ranGenCount1 == true, "The generator actually ran!");
  ASSERT(count1Module->hasDef()==true,"this module now has a definition");
  cout << "We should have just seen our message from the generator function print to stdout" << endl << endl;


  //Now that we ran the generator, we cannot run it again, because it is cached.
  bool ranGenCount1_try2 = count1Module->runGenerator();
  ASSERT(ranGenCount1_try2 == false, "The generator did not run again for the same arguments!");
  
  //One thing to note here is that the fact that we provided an explicit defintion for width=32,has_en=false, overrides the general generator function. So if we try to run the generator for count0Module, we will not be able to.
  bool ranGenCount0 = count0Module->runGenerator();
  ASSERT(ranGenCount0 == false, "The generator did not run because it already had a definition!");

  //For simplicity, coreir has a compiler pass which recursively runs all the generators that it can. This could have been used instead of explicitly calling runGenerator() on each generated module. 
  //c->runPasses({"rungenerators"});

  //Lets check to see what the generator generated!
  cout << "Printing the generated module of count1!" << endl;
  count1Module->print();  
 
  //And lets make sure all the inputs are being driven.
  c->runPasses({"verifyconnectivity --onlyinputs"});

  //Now lets actually save this to a real file.
  //Specify the namespace to save (global), the filename, and an optional "top" module
  saveToFile(global,"_counters.json",top);
  //We should see in the file our top, our specified defintion for count0, and our generated defintion for count1


  //Always remember to delete your context!
  deleteContext(c);
  return 0;
}
